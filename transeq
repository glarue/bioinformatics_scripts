#!/usr/bin/env python3
"""
usage: translator.py [-h] [-v {short,long}] [-p {1,2}] [-r]
                     [-s STOP_CHARACTER] [--no_mask]
                     [sequence_input]

Translate nucleotide sequence into amino acid sequence

positional arguments:
  sequence_input        sequence string or file containing sequence(s)
                        (default: None)

optional arguments:
  -h, --help            show this help message and exit
  -v {short,long}, --verbosity {short,long}
                        amino acid abbreviation length (e.g. Glu/Glutamine)
                        (default: single)
  -p {1,2}, --phase {1,2}
                        change the phase of translation (default: 0)
  -r, --reverse_complement
                        reverse-complement the sequence before translation
                        (default: False)
  -s STOP_CHARACTER, --stop_character STOP_CHARACTER
                        the string to use for stop codons (default: None)
  --no_mask             do not mask unrecognized codons with X; report
                        lowercased (default: False)
"""
import sys
import os
import argparse
from biogl import fasta_parse, translate, rev_comp


def parse_seq(s):
    if s.startswith(">"):
        print(s.strip())
        return
    if rev_choice is True:
        s = rev_comp(s)
    aas = translate(
        s, 
        verbosity=v_level, 
        phase=phase_choice,
        stop_char=STOP_CHAR)
    print(aas, flush=True)

def reverse_complement(seq):
    """
    Returns reverse complement of seq, with
    any non-ACTG characters replaced with Ns

    """
    transform = {'A': 'T',
                 'T': 'A',
                 'C': 'G',
                 'G': 'C',
                 'N': 'N'}
    try:
        comp = [transform[e] for e in seq]
    except KeyError:  # non-ATCGN characters in seq
        seq = [e if e in "ACTGN" else "N" for e in seq]
        comp = [transform[e] for e in seq]
    rev_comp = comp[::-1]
    rev_comp_string = ''.join(rev_comp)
    return rev_comp_string

def parse_file(seqFile):
    """
    Do translation if input is a file.

    """
    isFasta = False
    with open(seqFile) as f:
        if any(l.startswith(">") for l in f):
            isFasta = True

    if isFasta:
        for h, s in fasta_parse(seqFile, separator=""):
            if rev_choice is True:
                s = reverse_complement(s)
            aas = translate(
                s, 
                verbosity=v_level, 
                phase=phase_choice, 
                stop_char=STOP_CHAR)
            print(">" + h + "\t")
            print(aas, flush=True)
    else:
        with open(seqFile) as f:
            for l in f:
                l = l.strip()
                if rev_choice is True:
                    l = rev_comp(l)
                aas = translate(
                    l, 
                    verbosity=v_level, 
                    phase=phase_choice, 
                    stop_char=STOP_CHAR)
                print(aas, flush=True)

parser = argparse.ArgumentParser(
    description='Translate nucleotide sequence into amino acid sequence',
    formatter_class=argparse.ArgumentDefaultsHelpFormatter
)
parser.add_argument(
    'sequence_input',
    nargs='?',
    help='sequence string or file containing sequence(s)'
)
parser.add_argument(
    '-v',
    '--verbosity',
    help='amino acid abbreviation length (e.g. Glu/Glutamine)',
    choices=['short', 'long'],
    default='single'
)
parser.add_argument(
    '-p',
    '--phase',
    help='change the phase of translation',
    type=int,
    choices=[1, 2],
    default=0
)
parser.add_argument(
    '-r',
    '--reverse_complement',
    help='reverse-complement the sequence before translation',
    action='store_true'
)
parser.add_argument(
    '-s',
    '--stop_character',
    help='the string to use for stop codons',
    type=str,
    default='*'
)
parser.add_argument(
    '--no_mask',
    action='store_true',
    help='do not mask unrecognized codons with X; report lowercased'
)

args = parser.parse_args()

# this is convoluted, but allows for piping in of sequence
seq_input = args.sequence_input
if not seq_input:
    if not sys.stdin.isatty():
        seq_input = sys.stdin
    else:
        parser.print_help()
        sys.exit(0)
        
v_level = args.verbosity
phase_choice = args.phase
rev_choice = args.reverse_complement
NO_MASK = args.no_mask
STOP_CHAR = args.stop_character

try:
    if os.path.isfile(seq_input):
        parse_file(seq_input)  
    else:
        parse_seq(seq_input)
except TypeError:
    for line in seq_input.readlines():
        parse_seq(line)


sys.exit(0)
